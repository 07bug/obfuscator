diff --git a/llvm/include/llvm/InitializePasses.h b/llvm/include/llvm/InitializePasses.h
index 3ceb4c4cbc29..489ef045796f 100644
--- a/llvm/include/llvm/InitializePasses.h
+++ b/llvm/include/llvm/InitializePasses.h
@@ -166,7 +166,6 @@ void initializeFinalizeMachineBundlesPass(PassRegistry&);
 void initializeFixIrreduciblePass(PassRegistry &);
 void initializeFixupStatepointCallerSavedPass(PassRegistry&);
 void initializeFlattenCFGLegacyPassPass(PassRegistry &);
-void initializeFlatteningPass(PassRegistry&);
 void initializeFloat2IntLegacyPassPass(PassRegistry&);
 void initializeForceFunctionAttrsLegacyPassPass(PassRegistry&);
 void initializeForwardControlFlowIntegrityPass(PassRegistry&);
diff --git a/llvm/include/llvm/Transforms/Obfuscation/BogusControlFlow.h b/llvm/include/llvm/Transforms/Obfuscation/BogusControlFlow.h
index 0e8c935de99a..0feb986f7b57 100644
--- a/llvm/include/llvm/Transforms/Obfuscation/BogusControlFlow.h
+++ b/llvm/include/llvm/Transforms/Obfuscation/BogusControlFlow.h
@@ -32,10 +32,17 @@
 #include "llvm/Transforms/Obfuscation/CryptoUtils.h"
 #include "llvm/Transforms/Utils/BasicBlockUtils.h"
 #include "llvm/Transforms/Utils/Cloning.h"
+#include "llvm/IR/PassManager.h" //new Pass
 
 namespace llvm {
-Pass *createBogus();
-Pass *createBogus(bool flag);
+    Pass *createBogus();
+    Pass *createBogus(bool flag);
+    class BogusControlFlowPass : public PassInfoMixin<BogusControlFlowPass>{ 
+        public:
+            PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);
+
+            static bool isRequired() { return true; }
+    };
 } // namespace llvm
 
 #endif
diff --git a/llvm/include/llvm/Transforms/Obfuscation/CryptoUtils.h b/llvm/include/llvm/Transforms/Obfuscation/CryptoUtils.h
index 1994ec002b90..b69c947e580d 100644
--- a/llvm/include/llvm/Transforms/Obfuscation/CryptoUtils.h
+++ b/llvm/include/llvm/Transforms/Obfuscation/CryptoUtils.h
@@ -66,12 +66,12 @@ extern ManagedStatic<CryptoUtils> cryptoutils;
 #endif
 #define ENDIAN_64BITWORD
 
-#elif defined(__sparc)
+#elif defined(__sparc) || defined(__aarch64__)
 
 #ifndef ENDIAN_BIG
 #define ENDIAN_BIG
 #endif
-#if defined(__arch64__)
+#if defined(__arch64__) || defined(__aarch64__)
 #define ENDIAN_64BITWORD
 #else
 #define ENDIAN_32BITWORD
diff --git a/llvm/include/llvm/Transforms/Obfuscation/Flattening.h b/llvm/include/llvm/Transforms/Obfuscation/Flattening.h
index fd647a0517b5..15c6733e112b 100644
--- a/llvm/include/llvm/Transforms/Obfuscation/Flattening.h
+++ b/llvm/include/llvm/Transforms/Obfuscation/Flattening.h
@@ -24,9 +24,16 @@
 #include "llvm/Transforms/Obfuscation/Utils.h"
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/Local.h" // For DemoteRegToStack and DemotePHIToStack
+#include "llvm/IR/PassManager.h" //new Pass
 
 namespace llvm {
-Pass *createFlattening(bool flag);
+    Pass *createFlattening(bool flag);
+    class FlatteningPass : public PassInfoMixin<FlatteningPass>{ 
+        public:
+            PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);
+
+            static bool isRequired() { return true; }
+    };
 } // namespace llvm
 
 #endif
diff --git a/llvm/include/llvm/Transforms/Obfuscation/Split.h b/llvm/include/llvm/Transforms/Obfuscation/Split.h
index 6b0c56ca1262..200c365f2b19 100644
--- a/llvm/include/llvm/Transforms/Obfuscation/Split.h
+++ b/llvm/include/llvm/Transforms/Obfuscation/Split.h
@@ -23,9 +23,16 @@
 #include "llvm/Transforms/Obfuscation/Utils.h"
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/Local.h" // For DemoteRegToStack and DemotePHIToStack
+#include "llvm/IR/PassManager.h" //new Pass
 
 namespace llvm {
-Pass *createSplitBasicBlock(bool flag);
+    Pass *createSplitBasicBlock(bool flag);
+    class SplitBasicBlockPass : public PassInfoMixin<SplitBasicBlockPass>{ 
+        public:
+            PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);
+
+            static bool isRequired() { return true; }
+    };
 }
 
 #endif
diff --git a/llvm/include/llvm/Transforms/Obfuscation/StringObfuscation.h b/llvm/include/llvm/Transforms/Obfuscation/StringObfuscation.h
index b902332b9e39..16e804fb7d90 100755
--- a/llvm/include/llvm/Transforms/Obfuscation/StringObfuscation.h
+++ b/llvm/include/llvm/Transforms/Obfuscation/StringObfuscation.h
@@ -1,6 +1,13 @@
 // LLVM include
 #include "llvm/Pass.h"
+#include "llvm/IR/PassManager.h" //new Pass
 
 namespace llvm {
       Pass* createStringObfuscation(bool flag);
+      class StringObfuscationPass : public PassInfoMixin<StringObfuscationPass>{ 
+        public:
+            PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);
+
+            static bool isRequired() { return true; }
+      };
 }
diff --git a/llvm/include/llvm/Transforms/Obfuscation/Substitution.h b/llvm/include/llvm/Transforms/Obfuscation/Substitution.h
index 1b524c26b20a..0d6ef76057b8 100644
--- a/llvm/include/llvm/Transforms/Obfuscation/Substitution.h
+++ b/llvm/include/llvm/Transforms/Obfuscation/Substitution.h
@@ -22,9 +22,16 @@
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/IPO.h"
 #include "llvm/Transforms/Obfuscation/CryptoUtils.h"
+#include "llvm/IR/PassManager.h" //new Pass
 
 namespace llvm {
-Pass *createSubstitution(bool flag);
+    Pass *createSubstitution(bool flag);
+    class SubstitutionPass : public PassInfoMixin<SubstitutionPass>{ 
+        public:
+            PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);
+
+            static bool isRequired() { return true; }
+    };
 } // namespace llvm
 
 #endif
diff --git a/llvm/lib/Passes/CMakeLists.txt b/llvm/lib/Passes/CMakeLists.txt
index 703969f8b5f4..c58f336900a3 100644
--- a/llvm/lib/Passes/CMakeLists.txt
+++ b/llvm/lib/Passes/CMakeLists.txt
@@ -27,4 +27,5 @@ add_llvm_component_library(LLVMPasses
   TransformUtils
   Vectorize
   Instrumentation
+  Obfuscation
   )
diff --git a/llvm/lib/Passes/PassBuilder.cpp b/llvm/lib/Passes/PassBuilder.cpp
index dedfc81f11bb..6227e62c4e97 100644
--- a/llvm/lib/Passes/PassBuilder.cpp
+++ b/llvm/lib/Passes/PassBuilder.cpp
@@ -244,6 +244,11 @@
 #include "llvm/Transforms/Vectorize/LoopVectorize.h"
 #include "llvm/Transforms/Vectorize/SLPVectorizer.h"
 #include "llvm/Transforms/Vectorize/VectorCombine.h"
+#include "llvm/Transforms/Obfuscation/Flattening.h"
+#include "llvm/Transforms/Obfuscation/Substitution.h"
+#include "llvm/Transforms/Obfuscation/BogusControlFlow.h"
+#include "llvm/Transforms/Obfuscation/Split.h"
+#include "llvm/Transforms/Obfuscation/StringObfuscation.h"
 
 using namespace llvm;
 
diff --git a/llvm/lib/Passes/PassBuilderPipelines.cpp b/llvm/lib/Passes/PassBuilderPipelines.cpp
index e838665eb9ce..89e8b3bd5f13 100644
--- a/llvm/lib/Passes/PassBuilderPipelines.cpp
+++ b/llvm/lib/Passes/PassBuilderPipelines.cpp
@@ -127,6 +127,13 @@
 #include "llvm/Transforms/Vectorize/SLPVectorizer.h"
 #include "llvm/Transforms/Vectorize/VectorCombine.h"
 
+#include "llvm/Transforms/Utils/LowerSwitch.h"
+#include "llvm/Transforms/Obfuscation/Flattening.h"
+#include "llvm/Transforms/Obfuscation/Substitution.h"
+#include "llvm/Transforms/Obfuscation/BogusControlFlow.h"
+#include "llvm/Transforms/Obfuscation/Split.h"
+#include "llvm/Transforms/Obfuscation/StringObfuscation.h"
+
 using namespace llvm;
 
 static cl::opt<InliningAdvisorMode> UseInlineAdvisor(
@@ -182,6 +189,12 @@ static cl::opt<bool> EnableMergeFunctions(
     "enable-merge-functions", cl::init(false), cl::Hidden,
     cl::desc("Enable function merging as part of the optimization pipeline"));
 
+static cl::opt<std::string> AesSeed("aesSeed", cl::init(""),
+                                    cl::desc("seed for the AES-CTR PRNG"));
+
+static cl::opt<std::string> Seed("seed", cl::init(""),
+                           cl::desc("seed for the random"));
+
 PipelineTuningOptions::PipelineTuningOptions() {
   LoopInterleaving = true;
   LoopVectorization = true;
@@ -193,6 +206,15 @@ PipelineTuningOptions::PipelineTuningOptions() {
   CallGraphProfile = true;
   MergeFunctions = EnableMergeFunctions;
   EagerlyInvalidateAnalyses = EnableEagerlyInvalidateAnalyses;
+
+  if(!AesSeed.empty()) {
+    llvm::cryptoutils->prng_seed(AesSeed.c_str());
+  }
+
+  //random generator
+  if(!Seed.empty()) {
+    llvm::cryptoutils->prng_seed(Seed.c_str());
+  }
 }
 
 namespace llvm {
@@ -1171,6 +1193,15 @@ PassBuilder::buildModuleOptimizationPipeline(OptimizationLevel Level,
   MPM.addPass(RequireAnalysisPass<GlobalsAA, Module>());
 
   FunctionPassManager OptimizePM;
+
+  // Obfuscation
+  OptimizePM.addPass(SplitBasicBlockPass());
+  OptimizePM.addPass(BogusControlFlowPass());
+  #if LLVM_VERSION_MAJOR >= 9
+    OptimizePM.addPass(LowerSwitchPass());
+  #endif
+  OptimizePM.addPass(FlatteningPass());
+
   OptimizePM.addPass(Float2IntPass());
   OptimizePM.addPass(LowerConstantIntrinsicsPass());
 
@@ -1238,6 +1269,10 @@ PassBuilder::buildModuleOptimizationPipeline(OptimizationLevel Level,
   MPM.addPass(createModuleToFunctionPassAdaptor(std::move(OptimizePM),
                                                 PTO.EagerlyInvalidateAnalyses));
 
+  // Obfuscation  
+  OptimizePM.addPass(SubstitutionPass());
+  MPM.addPass(StringObfuscationPass());
+
   for (auto &C : OptimizerLastEPCallbacks)
     C(MPM, Level);
 
diff --git a/llvm/lib/Passes/PassRegistry.def b/llvm/lib/Passes/PassRegistry.def
index 69d8d8c43267..62251cdb9a44 100644
--- a/llvm/lib/Passes/PassRegistry.def
+++ b/llvm/lib/Passes/PassRegistry.def
@@ -119,6 +119,8 @@ MODULE_PASS("sancov-module", ModuleSanitizerCoveragePass())
 MODULE_PASS("memprof-module", ModuleMemProfilerPass())
 MODULE_PASS("poison-checking", PoisonCheckingPass())
 MODULE_PASS("pseudo-probe-update", PseudoProbeUpdatePass())
+MODULE_PASS("obf-str", StringObfuscationPass())
+
 #undef MODULE_PASS
 
 #ifndef MODULE_PASS_WITH_PARAMS
@@ -265,6 +267,10 @@ FUNCTION_PASS("make-guards-explicit", MakeGuardsExplicitPass())
 FUNCTION_PASS("gvn-hoist", GVNHoistPass())
 FUNCTION_PASS("gvn-sink", GVNSinkPass())
 FUNCTION_PASS("helloworld", HelloWorldPass())
+FUNCTION_PASS("obf-fla", FlatteningPass())
+FUNCTION_PASS("obf-sub", SubstitutionPass())
+FUNCTION_PASS("obf-bcf", BogusControlFlowPass())
+FUNCTION_PASS("obf-split", SplitBasicBlockPass())
 FUNCTION_PASS("infer-address-spaces", InferAddressSpacesPass())
 FUNCTION_PASS("instcombine", InstCombinePass())
 FUNCTION_PASS("instcount", InstCountPass())
diff --git a/llvm/lib/Transforms/IPO/CMakeLists.txt b/llvm/lib/Transforms/IPO/CMakeLists.txt
index a0cddafb784e..f9833224d142 100644
--- a/llvm/lib/Transforms/IPO/CMakeLists.txt
+++ b/llvm/lib/Transforms/IPO/CMakeLists.txt
@@ -73,5 +73,4 @@ add_llvm_component_library(LLVMipo
   Vectorize
   Instrumentation
   Scalar
-  Obfuscation
   )
diff --git a/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp b/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp
index 7f2ca4f2b4c9..6e5aeb9c41f6 100644
--- a/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp
+++ b/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp
@@ -52,13 +52,6 @@
 #include "llvm/Transforms/Vectorize/SLPVectorizer.h"
 #include "llvm/Transforms/Vectorize/VectorCombine.h"
 
-#include "llvm/Transforms/Obfuscation/BogusControlFlow.h"
-#include "llvm/Transforms/Obfuscation/Flattening.h"
-#include "llvm/Transforms/Obfuscation/Split.h"
-#include "llvm/Transforms/Obfuscation/Substitution.h"
-#include "llvm/Transforms/Obfuscation/StringObfuscation.h"
-#include "llvm/Transforms/Obfuscation/CryptoUtils.h"
-
 using namespace llvm;
 
 namespace llvm {
@@ -155,28 +148,6 @@ cl::opt<bool>
     EnableGVNSink("enable-gvn-sink", cl::init(false), cl::ZeroOrMore,
                   cl::desc("Enable the GVN sinking pass (default = off)"));
 
-// Flags for obfuscation
-static cl::opt<bool> Flattening("fla", cl::init(false),
-                                cl::desc("Enable the flattening pass"));
-
-static cl::opt<bool> BogusControlFlow("bcf", cl::init(false),
-                                      cl::desc("Enable bogus control flow"));
-
-static cl::opt<bool> Substitution("sub", cl::init(false),
-                                  cl::desc("Enable instruction substitutions"));
-
-static cl::opt<std::string> AesSeed("aesSeed", cl::init(""),
-                                    cl::desc("seed for the AES-CTR PRNG"));
-
-static cl::opt<bool> Split("split", cl::init(false),
-                           cl::desc("Enable basic block splitting"));
-
-static cl::opt<std::string> Seed("seed", cl::init(""),
-                           cl::desc("seed for the random"));
-
-static cl::opt<bool> StringObf("sobf", cl::init(false),
-                           cl::desc("Enable the string obfuscation"));
-
 // This option is used in simplifying testing SampleFDO optimizations for
 // profile loading.
 cl::opt<bool>
@@ -249,21 +220,6 @@ PassManagerBuilder::PassManagerBuilder() {
     PerformThinLTO = EnablePerformThinLTO;
     DivergentTarget = false;
     CallGraphProfile = true;
-
-    // Initialization of the global cryptographically
-    // secure pseudo-random generator
-    if(!AesSeed.empty()) {
-        if(!llvm::cryptoutils->prng_seed(AesSeed.c_str())) {
-          exit(1);
-        }
-    }
-
-    //random generator
-    if(!Seed.empty()) {
-        if(!llvm::cryptoutils->prng_seed(Seed.c_str()))
-          exit(1);
-    }
-
 }
 
 PassManagerBuilder::~PassManagerBuilder() {
@@ -737,14 +693,6 @@ void PassManagerBuilder::populateModulePassManager(
   // Allow forcing function attributes as a debugging and tuning aid.
   MPM.add(createForceFunctionAttrsLegacyPass());
 
-  MPM.add(createSplitBasicBlock(Split));
-  MPM.add(createBogus(BogusControlFlow));
-  #if LLVM_VERSION_MAJOR >= 9
-    MPM.add(createLowerSwitchPass());
-  #endif
-  MPM.add(createFlattening(Flattening));
-  MPM.add(createStringObfuscation(StringObf));
-
   // If all optimizations are disabled, just run the always-inline pass and,
   // if enabled, the function merging pass.
   if (OptLevel == 0) {
@@ -773,8 +721,6 @@ void PassManagerBuilder::populateModulePassManager(
       MPM.add(createGlobalDCEPass());
     }
 
-    MPM.add(createSubstitution(Substitution));
-
     addExtensionsToPM(EP_EnabledOnOptLevel0, MPM);
 
     if (PrepareForLTO || PrepareForThinLTO) {
@@ -1045,7 +991,6 @@ void PassManagerBuilder::populateModulePassManager(
   // flattening of blocks.
   MPM.add(createDivRemPairsPass());
 
-  MPM.add(createSubstitution(Substitution));
   // LoopSink (and other loop passes since the last simplifyCFG) might have
   // resulted in single-entry-single-exit or empty blocks. Clean up the CFG.
   MPM.add(createCFGSimplificationPass(
diff --git a/llvm/lib/Transforms/Obfuscation/BogusControlFlow.cpp b/llvm/lib/Transforms/Obfuscation/BogusControlFlow.cpp
index 145a15464d9d..a085d68259f7 100644
--- a/llvm/lib/Transforms/Obfuscation/BogusControlFlow.cpp
+++ b/llvm/lib/Transforms/Obfuscation/BogusControlFlow.cpp
@@ -126,7 +126,7 @@ static cl::opt<int>
              cl::desc("Choose how many time the -bcf pass loop on a function"),
              cl::value_desc("number of times"), cl::init(defaultObfTime),
              cl::Optional);
-
+                                      
 namespace {
 struct BogusControlFlow : public FunctionPass {
   static char ID; // Pass identification
@@ -143,28 +143,31 @@ struct BogusControlFlow : public FunctionPass {
    * to the function. See header for more details.
    */
   virtual bool runOnFunction(Function &F) {
-    // Check if the percentage is correct
-    if (ObfTimes <= 0) {
-      errs() << "BogusControlFlow application number -bcf_loop=x must be x > 0";
-      return false;
-    }
-
-    // Check if the number of applications is correct
-    if (!((ObfProbRate > 0) && (ObfProbRate <= 100))) {
-      errs() << "BogusControlFlow application basic blocks percentage "
-                "-bcf_prob=x must be 0 < x <= 100";
-      return false;
-    }
     // If fla annotations
     if (toObfuscate(flag, &F, "bcf")) {
-      bogus(F);
-      doF(*F.getParent());
-      return true;
+      return runOnCustomFunction(F);
     }
 
     return false;
   } // end of runOnFunction()
 
+  bool runOnCustomFunction(Function &F) {
+      if (ObfTimes <= 0) {
+        errs() << "BogusControlFlow application number -bcf_loop=x must be x > 0";
+        return false;
+      }
+
+      // Check if the number of applications is correct
+      if (!((ObfProbRate > 0) && (ObfProbRate <= 100))) {
+        errs() << "BogusControlFlow application basic blocks percentage "
+                  "-bcf_prob=x must be 0 < x <= 100";
+        return false;
+      }
+      bogus(F);
+      doF(*F.getParent());
+      return true;
+  } // end of runOnFunction()
+
   void bogus(Function &F) {
     // For statistics and debug
     ++NumFunction;
@@ -203,7 +206,8 @@ struct BogusControlFlow : public FunctionPass {
       // Put all the function's block in a list
       std::list<BasicBlock *> basicBlocks;
       for (Function::iterator i = F.begin(); i != F.end(); ++i) {
-        basicBlocks.push_back(&*i);
+          if (!i->isEHPad())
+            basicBlocks.push_back(&*i);
       }
       DEBUG_WITH_TYPE(
           "gen", errs() << "bcf: Iterating on the Function's Basic Blocks\n");
@@ -682,3 +686,10 @@ static RegisterPass<BogusControlFlow> X("boguscf",
 Pass *llvm::createBogus() { return new BogusControlFlow(); }
 
 Pass *llvm::createBogus(bool flag) { return new BogusControlFlow(flag); }
+
+PreservedAnalyses BogusControlFlowPass::run(Function& F, FunctionAnalysisManager& AM) {
+  BogusControlFlow bcf;
+  if (bcf.runOnCustomFunction(F))
+    return PreservedAnalyses::none();
+  return PreservedAnalyses::all();
+}
diff --git a/llvm/lib/Transforms/Obfuscation/Flattening.cpp b/llvm/lib/Transforms/Obfuscation/Flattening.cpp
index c219cfa7b38f..c129eedd9931 100644
--- a/llvm/lib/Transforms/Obfuscation/Flattening.cpp
+++ b/llvm/lib/Transforms/Obfuscation/Flattening.cpp
@@ -23,6 +23,9 @@ using namespace llvm;
 // Stats
 STATISTIC(Flattened, "Functions flattened");
 
+static cl::opt<bool> FlatteningFlag("fla", cl::init(false),
+                                cl::desc("Enable the flattening pass"));
+
 namespace {
 struct Flattening : public FunctionPass {
   static char ID; // Pass identification, replacement for typeid
@@ -32,6 +35,7 @@ struct Flattening : public FunctionPass {
   Flattening(bool flag) : FunctionPass(ID) { this->flag = flag; }
 
   bool runOnFunction(Function &F);
+  void runOnCustomFunction(Function *F);
   bool flatten(Function *f);
 };
 } // namespace
@@ -44,14 +48,18 @@ bool Flattening::runOnFunction(Function &F) {
   Function *tmp = &F;
   // Do we obfuscate
   if (toObfuscate(flag, tmp, "fla")) {
-    if (flatten(tmp)) {
-      ++Flattened;
-    }
+    runOnCustomFunction(tmp);
   }
 
   return false;
 }
 
+void Flattening::runOnCustomFunction(Function *F) {
+    if (flatten(F)) {
+      ++Flattened;
+    }
+}
+
 bool Flattening::flatten(Function *f) {
   std::vector<BasicBlock *> origBB;
   BasicBlock *loopEntry;
@@ -103,6 +111,7 @@ bool Flattening::flatten(Function *f) {
     br = cast<BranchInst>(insert->getTerminator());
   }
 
+  BasicBlock *zeroBB = NULL;
   if ((br != NULL && br->isConditional()) ||
       insert->getTerminator()->getNumSuccessors() > 1) {
     BasicBlock::iterator i = insert->end();
@@ -115,6 +124,10 @@ bool Flattening::flatten(Function *f) {
     BasicBlock *tmpBB = insert->splitBasicBlock(i, "first");
     origBB.insert(origBB.begin(), tmpBB);
   }
+  else if (br != NULL && insert->getTerminator()->getNumSuccessors() == 1) {
+    // Record the first BB branch to
+    zeroBB = insert->getTerminator()->getSuccessor(0);
+  }
 
   // Remove jump
   insert->getTerminator()->eraseFromParent();
@@ -166,7 +179,14 @@ bool Flattening::flatten(Function *f) {
     numCase = cast<ConstantInt>(ConstantInt::get(
         switchI->getCondition()->getType(),
         llvm::cryptoutils->scramble32(switchI->getNumCases(), scrambling_key)));
-    switchI->addCase(numCase, i);
+    if (zeroBB && zeroBB != i) {
+        switchI->addCase(numCase, zeroBB);
+        zeroBB = NULL;
+    }
+    else {
+        switchI->addCase(numCase, i);
+    }
+
   }
 
   // Recalculate switchVar
@@ -246,3 +266,10 @@ bool Flattening::flatten(Function *f) {
 
   return true;
 }
+
+PreservedAnalyses FlatteningPass::run(Function& F, FunctionAnalysisManager& AM) {
+  Flattening fla;
+  Function *tmp = &F;
+  fla.runOnCustomFunction(tmp);
+  return PreservedAnalyses::none();
+}
diff --git a/llvm/lib/Transforms/Obfuscation/SplitBasicBlocks.cpp b/llvm/lib/Transforms/Obfuscation/SplitBasicBlocks.cpp
index 6da8b5b72faf..a7c6c3755465 100644
--- a/llvm/lib/Transforms/Obfuscation/SplitBasicBlocks.cpp
+++ b/llvm/lib/Transforms/Obfuscation/SplitBasicBlocks.cpp
@@ -34,6 +34,7 @@ struct SplitBasicBlock : public FunctionPass {
   SplitBasicBlock(bool flag) : FunctionPass(ID) { this->flag = flag; }
 
   bool runOnFunction(Function &F);
+  void runOnCustomFunction(Function *F);
   void split(Function *f);
 
   bool containsPHI(BasicBlock *b);
@@ -49,24 +50,27 @@ Pass *llvm::createSplitBasicBlock(bool flag) {
 }
 
 bool SplitBasicBlock::runOnFunction(Function &F) {
-  // Check if the number of applications is correct
-  if (!((SplitNum > 1) && (SplitNum <= 10))) {
-    errs() << "Split application basic block percentage\
-            -split_num=x must be 1 < x <= 10";
-    return false;
-  }
-
   Function *tmp = &F;
 
   // Do we obfuscate
   if (toObfuscate(flag, tmp, "split")) {
-    split(tmp);
-    ++Split;
+    runOnCustomFunction(tmp);
   }
 
   return false;
 }
 
+void SplitBasicBlock::runOnCustomFunction(Function *F) {
+    // Check if the number of applications is correct
+    if (!((SplitNum > 1) && (SplitNum <= 10))) {
+      errs() << "Split application basic block percentage\
+              -split_num=x must be 1 < x <= 10";
+      return;
+    }
+    split(F);
+    ++Split;
+}
+
 void SplitBasicBlock::split(Function *f) {
   std::vector<BasicBlock *> origBB;
   int splitN = SplitNum;
@@ -137,3 +141,10 @@ void SplitBasicBlock::shuffle(std::vector<int> &vec) {
     std::swap(vec[i], vec[cryptoutils->get_uint32_t() % (i + 1)]);
   }
 }
+
+PreservedAnalyses SplitBasicBlockPass::run(Function& F, FunctionAnalysisManager& AM) {
+  SplitBasicBlock split;
+  Function *tmp = &F;
+  split.runOnCustomFunction(tmp);
+  return PreservedAnalyses::none();
+}
\ No newline at end of file
diff --git a/llvm/lib/Transforms/Obfuscation/StringObfuscation.cpp b/llvm/lib/Transforms/Obfuscation/StringObfuscation.cpp
index 394e54a3a9d2..41a8d468068a 100755
--- a/llvm/lib/Transforms/Obfuscation/StringObfuscation.cpp
+++ b/llvm/lib/Transforms/Obfuscation/StringObfuscation.cpp
@@ -1,4 +1,3 @@
-#define DEBUG_TYPE "objdiv"
 #include <string>
 #include <sstream>
 
@@ -16,6 +15,8 @@
 #include "llvm/Transforms/Utils/ModuleUtils.h"
 #include "llvm/IR/Instructions.h"
 
+#define DEBUG_TYPE "objdiv"
+
 using namespace llvm;
 
 STATISTIC(GlobalsEncoded, "Counts number of global variables encoded");
@@ -28,12 +29,12 @@ namespace llvm {
                         uint8_t key;
         };
 
-        class StringObfuscationPass: public llvm::ModulePass {
+        class StringObfuscation: public llvm::ModulePass {
                 public:
                 static char ID; // pass identification
                 bool is_flag = false;
-                StringObfuscationPass() : ModulePass(ID) {}
-                StringObfuscationPass(bool flag) : ModulePass(ID)
+                StringObfuscation() : ModulePass(ID) {}
+                StringObfuscation(bool flag) : ModulePass(ID)
                 {
                     is_flag = flag;
                 }
@@ -41,6 +42,11 @@ namespace llvm {
                 virtual bool runOnModule(Module &M) {
                         if(!is_flag)
                             return false;
+
+                        return runCustomModule(M);
+                }
+
+                bool runCustomModule(Module &M){
                         std::vector<GlobalVariable*> toDelConstGlob;
                         //std::vector<GlobalVariable*> encGlob;
                         std::vector<encVar*> encGlob;
@@ -116,8 +122,6 @@ namespace llvm {
                                 toDelConstGlob[i]->eraseFromParent();
 
                         addDecodeFunction(&M, &encGlob);
-
-
                         return true;
                 }
 
@@ -175,8 +179,14 @@ namespace llvm {
                                 //errs()<<"Load: "<<*(Load->getPointerOperand())<<"\n";
                                 Value* indexList[2] = {ConstantInt::get(variable->getType(), 0), variable};
                                 Value *const_key=builder.getInt8(key);
-                                Value *GEP=builder.CreateGEP(gvar,ArrayRef<Value*>(indexList, 2),"arrayIdx");
-                                LoadInst *loadElement=builder.CreateLoad(GEP,false);
+                                #if LLVM_VERSION_MAJOR >= 14
+                                        Value *GEP=builder.CreateGEP(gvar->getType()->getScalarType()->getPointerElementType(),gvar,ArrayRef<Value*>(indexList, 2),"arrayIdx");
+                                        LoadInst *loadElement=builder.CreateLoad(GEP->getType()->getScalarType()->getPointerElementType(),GEP,false);
+                                #else
+                                        Value *GEP=builder.CreateGEP(gvar,ArrayRef<Value*>(indexList, 2),"arrayIdx");
+                                        LoadInst *loadElement=builder.CreateLoad(GEP,false);
+                                #endif
+                                
                                 loadElement->setAlignment(Align(1));
                                 //errs()<<"Type: "<<*loadElement<<"\n";
                                 //CastInst* extended = new ZExtInst(const_key, loadElement->getType(), "extended", for_body);
@@ -206,9 +216,16 @@ namespace llvm {
 
 }
 
-char StringObfuscationPass::ID = 0;
-static RegisterPass<StringObfuscationPass> X("GVDiv", "Global variable (i.e., const char*) diversification pass", false, true);
+char StringObfuscation::ID = 0;
+static RegisterPass<StringObfuscation> X("GVDiv", "Global variable (i.e., const char*) diversification pass", false, true);
 
 Pass * llvm::createStringObfuscation(bool flag) {
-    return new StringObfuscationPass(flag);
+    return new StringObfuscation(flag);
+}
+
+PreservedAnalyses StringObfuscationPass::run(Module &M, ModuleAnalysisManager& AM) {
+  StringObfuscation sop;
+  if (sop.runCustomModule(M))
+        return PreservedAnalyses::none();
+  return PreservedAnalyses::all();
 }
diff --git a/llvm/lib/Transforms/Obfuscation/Substitution.cpp b/llvm/lib/Transforms/Obfuscation/Substitution.cpp
index 340c62de66b2..abe3f4001e97 100644
--- a/llvm/lib/Transforms/Obfuscation/Substitution.cpp
+++ b/llvm/lib/Transforms/Obfuscation/Substitution.cpp
@@ -78,6 +78,7 @@ struct Substitution : public FunctionPass {
   }
 
   bool runOnFunction(Function &F);
+  bool runOnCustomFunction(Function *F);
   bool substitute(Function *f);
 
   void addNeg(BinaryOperator *bo);
@@ -105,21 +106,25 @@ static RegisterPass<Substitution> X("substitution", "operators substitution");
 Pass *llvm::createSubstitution(bool flag) { return new Substitution(flag); }
 
 bool Substitution::runOnFunction(Function &F) {
-  // Check if the percentage is correct
-  if (ObfTimes <= 0) {
-    errs() << "Substitution application number -sub_loop=x must be x > 0";
-    return false;
-  }
 
   Function *tmp = &F;
   // Do we obfuscate
   if (toObfuscate(flag, tmp, "sub")) {
-    substitute(tmp);
-    return true;
+    return runOnCustomFunction(tmp);
   }
   return false;
 }
 
+bool Substitution::runOnCustomFunction(Function *F) {
+  // Check if the percentage is correct
+  if (ObfTimes <= 0) {
+    errs() << "Substitution application number -sub_loop=x must be x > 0";
+    return false;
+  }
+  substitute(F);
+  return true;
+}
+
 bool Substitution::substitute(Function *f) {
   Function *tmp = f;
 
@@ -577,3 +582,11 @@ void Substitution::xorSubstitutionRand(BinaryOperator *bo) {
   op = BinaryOperator::Create(Instruction::Xor, op, op1, "", bo);
   bo->replaceAllUsesWith(op);
 }
+
+PreservedAnalyses SubstitutionPass::run(Function& F, FunctionAnalysisManager& AM) {
+  Substitution sub;
+  Function *tmp = &F;
+  if (sub.runOnCustomFunction(tmp))
+    return PreservedAnalyses::none();    
+  return PreservedAnalyses::all();
+}
